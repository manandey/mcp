import { z } from "zod";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { McpTool, McpToolConfig, ReleaseState, Toolset } from "@salesforce/mcp-provider-api";
import { promoteWorkItems } from "../utils/promoteWorkItems.js";
import { fetchWorkItemsByNames } from "../utils/devops-operations.js";

const DESCRIPTION: string = `Promotes approved Salesforce DevOps Work Items to the next pipeline stage/environment in the DevOps Center org.

**Use when user asks (examples):**
- "Promote WI-123 to UAT"
- "Promote my approved work item"
- "Release WI-456 to next stage"

**Prerequisites:**
- This tool must be used only for the DevOps Center org.
- The user must provide: username (DevOps Center) and a list of Work Item Names.

**Input Parameters:**
- username: DevOps Center org username. If missing, use 'sf-devopslist-orgs' and ask user to select the DevOps Center org.
- workItemNames: Array of exact Work Item Names to promote.

**Behavior:**
1. Fetches the specified Work Items by Name and derives PipelineId and TargetStageId automatically.
2. Validates that each Work Item has PipelineStageId and a resolvable TargetStageId.
3. Calls the promotion API with the resolved ids.

**Safety and guidance for the LLM:**
- Do not auto-select a non-DevOps Center org; always confirm with the user.
- If any Work Item is not found or missing required pipeline data, return an actionable error listing which names failed.
- Never promote without explicit user confirmation of workitems.

**Output:**
- JSON with promotion requestId (if available) and any error details.

**Next steps:**
- Suggest how to track promotion status using the returned requestId or the DevOps Center UI.
- If applicable, prompt the user to promote to the next stage after validation.

**Output:**
A JSON object containing the promotion request ID, the org details, and any relevant status or tracking information.`;

const inputSchema = z.object({
    username: z.string().describe("Username of the DevOps Center org"),
    workItemNames: z.array(z.string().min(1)).nonempty().describe("Exact Work Item Names to promote")
});
type InputArgsShape = typeof inputSchema.shape;

const outputSchema = z.object({
    requestId: z.string().optional().describe("Request ID for tracking promotion"),
    status: z.string().describe("Status of the promotion request"),
    workItems: z.array(z.object({
        name: z.string().describe("Work item name"),
        status: z.string().describe("Promotion status")
    })).describe("Status of each work item")
});
type OutputArgsShape = typeof outputSchema.shape;

/**
 * MCP tool for promoting work items through pipeline stages.
 */
export class SfDevopsPromoteWorkItemMcpTool extends McpTool<InputArgsShape, OutputArgsShape> {
    public static readonly NAME: string = 'sf-devops-promote-work-item';

    public constructor() {
        super();
    }

    public getReleaseState(): ReleaseState {
        return ReleaseState.NON_GA;
    }

    public getToolsets(): Toolset[] {
        return [Toolset.OTHER];
    }

    public getName(): string {
        return SfDevopsPromoteWorkItemMcpTool.NAME;
    }

    public getConfig(): McpToolConfig<InputArgsShape, OutputArgsShape> {
        return {
            title: "Promote DevOps Work Items",
            description: DESCRIPTION,
            inputSchema: inputSchema.shape,
            outputSchema: outputSchema.shape,
            annotations: {
                readOnlyHint: false
            }
        };
    }

    public async exec(input: { username: string; workItemNames: string[] }): Promise<CallToolResult> {
        try {
            const items = await fetchWorkItemsByNames(input.username, input.workItemNames);
            if (!Array.isArray(items) || items.length === 0) {
                return {
                    content: [{ type: "text", text: "No matching Work Items found for provided names." }],
                    isError: true
                };
            }

            const missing: string[] = [];
            const prepared = items.map((wi: any) => {
                if (!wi.id || !wi.TargetStageId || !wi.PipelineId) {
                    missing.push(wi.name || wi.id);
                }
                return {
                    id: wi.id,
                    PipelineStageId: wi.PipelineStageId || undefined,
                    TargetStageId: wi.TargetStageId,
                    PipelineId: wi.PipelineId
                };
            });

            if (missing.length) {
                return {
                    content: [{ type: "text", text: `Cannot promote due to missing pipeline data for: ${missing.join(", ")}. Ensure each item has a pipeline stage and target stage.` }],
                    isError: true
                };
            }

            const result = await promoteWorkItems(input.username, { workitems: prepared });
            
            // Format the response
            const response = {
                requestId: result.requestId,
                status: "Promotion request submitted",
                workItems: input.workItemNames.map(name => ({
                    name,
                    status: "Submitted for promotion"
                }))
            };

            return {
                content: [{ type: "text", text: JSON.stringify(response, null, 2) }],
                structuredContent: response
            };
        } catch (error) {
            const errorMessage = 'Operation failed. Please check your authentication and try again.';
            return {
                content: [{ type: "text", text: `Error promoting work items: ${errorMessage}` }],
                isError: true
            };
        }
    }
}
